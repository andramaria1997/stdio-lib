Copyright: Andra-Maria DANCIU

				README


--------- Implementation of standard I/O C library on a reduced scale ---------


# Compile:
	make -f GNUmakefile

# Checker:

The local directory must contain the so_stdio library (`libso_stdio.so`).
Use Makefile.checker to properly run the entire test suite:
```
	make -f Makefile.checker
```
The checker consists of the following files:
* `README.md` - this file
* `Makefile.checker` - Makefile for automating the build process on Linux
* `run_all.sh` - script to run all tests defined
* `_test` - directory that contains the following:
  * `run_test.sh` - runs only a specific test
  * `test_lib.sh` - a shell library used to run tests
  * `*.c` - source code for each test
  * `so_stdio.h` - so stdio header
  * `Makefile` - Makefile used for building the tests
  * `work/` - directory where tests output files are stored
If you want to keep the output files after running a test, you have to set
the `DO_CLEANUP` environment variable to `no`:
```
DO_CLEANUP=no make -f Makefile.checker
```
In order to run a single test, you can manually run the `run_test.sh` script:
```
_test/run_test.sh init
_test/run_test.sh <test>
_test/run_test.sh clean
```
where <test> is an integer specifying the test number

# Cleanup:

To clean the files generated by the checker you have to run:
```
make -f Makefile.checker clean
```


# Implementation of SO_FILE structure details:

 -> fd: file descriptor of SO_FILE stream, needed for syscalls (read, write,
    seek)
 -> buffer: 4KB bytes sized buffer used for reducing the number of syscalls on
    read/write in file
 -> file_pos: file cursor position (current offset from beginning of file)
 -> buf_data: number of bytes that file read can return without making another
    read syscall
 -> buf_pos: buffer index used for reading from buffer/writing in buffer
 -> last_op: flag for last operation made on file (read write or seek) in order
    to invalidate the buffer if necesarry (ex: fread after fseek)
 -> errno: error flag; set when one of file operations return error - 1;cleared
    when no error occured - 0
 -> feof: end of file flag set on 1 when read returns value <= 0


# Functions' implementation details:

SO_FILE *so_fopen(const char *pathname, const char *mode):
   opens the file found at pathname with permissions specified by mode
   parameter; when a file is opened, buffer is empty, file position is 0 (or
   size of file when opened with append), flags (last_op, errno, feof) are
   cleared; returns a stream associated with file descriptor returned

int so_fclose(SO_FILE *stream)
   closes the file descriptor that the stream is associated with and frees
   memory used by stream (SO_FILE structure); returns 0 un success and 1 on
   error

int so_fileno(SO_FILE *stream)
   returns file descriptor that the stream is associated with

int so_fflush(SO_FILE *stream)
   if the buffer used for holding data fills, all data contained is written
   to stream's file descriptor and buffer position is reset to 0; the buffer
   is flushed only if the previous operation was write, condition necesarry in
   order not to write in file data previously read and left in buffer, in case
   of a read/write file, or to avoid errors on fflush on a read only file

long so_ftell(SO_FILE *stream)
   returns position in file, associated to that stream

int so_fgetc(SO_FILE *stream)
   flushes data in case of a previous write, sets READ as the last operation
   made on file (stream's last_op flag), returns the character in buffer at
   current position then updates it; read syscall is made in case of full buff

size_t so_fread(void *ptr, size_t size, size_t nmemb, SO_FILE *stream)
   reads data from stream's file descriptor until size*nmemb bytes are returned
   and written in ptr buffer; flushes data in case of previous write and sets
   stream's last_op flag on READ; read syscall is called everytime data buffer
   fills, until end of file is reached or size*nmemb bytes are read from file;
   returns number of elements read

int so_fputc(int c, SO_FILE *stream)
   resets buffer index in case of a previous read (data is invalidated), sets
   stream's last_op flag on write and writes character c at current position in
   buffer; flushes buffer in case it fills; returns c on success
   
size_t so_fwrite(const void *ptr, size_t size, size_t nmemb, SO_FILE *stream)
   resets buffer index in case of a previous read (data is invalidated), sets
   stream's last_op flag on write and writes from user buffer to data buffer
   nmemb*size bytes, in pieces of BUFSIZE; buffer is flushed if filled; returns
   number of elements written in file

int so_fseek(SO_FILE *stream, long offset, int whence)
   flushes buffer in case of previous write, resets buffer index in case of
   previous read (invalidates data), sets stream's last_op flag on SEEK and
   updates file current position by moving file descriptors cursor using
   lseek syscall

int so_feof(SO_FILE *stream)
   returns 1 if end of file was reached by read syscall (stream's feof flag is
   set) and all data from buffer was read by user

int so_ferror(SO_FILE *stream)
   returns stream's errno flag, previously set if error occured

SO_FILE *so_popen(const char *command, const char *type)
   creates a pipe between parent process and child process; child process
   redirects stdin (in case of type w) or stdout (in case of type r) to pipe's
   corresponding file descriptor and executes command; parent process creates
   a SO_FILE structure associated with pipe's file descriptor and returns it

int so_pclose(SO_FILE *stream)
   closes pipe's file descriptor associated with the stream, waits for child
   process to finish its execution and frees the space allocated for stream

===============================================================================

# Cases not tested by checker:

-> fwrites and freads with size of element > 1; the case of writing in users
   buffer part of an element because of the value returned by read syscall can
   occur; solution: write in buffer readBytes - (readBytes % size)
-> incomplete writes (try to write BUFSIZE bytes in file, but 'write' syscall
   returns less); solution: try to write again, until the call returns a value
   <= 0
